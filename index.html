<!DOCTYPE html>
<html>
<head>
<title>EDURARY OFFICIAL WORD SEARCH GENERATOR</title>
<link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700;900&display=swap" rel="stylesheet">
<style>
/* --- BASE & UTILITY STYLES --- */
body {
    font-family: 'Lato', sans-serif;
    background: #f7f9fa;
    margin: 0;
    padding: 20px;
    color: #333;
    /* Custom properties for theme colors */
    --theme-primary-color: #0070c7;
    --theme-secondary-color: #0070c7;
    --highlight-color: #ffcc00;
    --app-background: #fff;
    --grid-line-color: #ddd;
    /* Custom property for print media query */
    --print-grid-border: 1px solid #000;
}
.app-container {
    max-width: 1200px;
    margin: 0 auto;
    background: var(--app-background);
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    display: flex;
    min-height: 80vh;
    border: 3px solid var(--theme-primary-color);
}
.classroom-header {
    display: flex;
    justify-content: space-between;
    margin-bottom: 20px;
    border-bottom: 1px dashed #ccc;
    padding-bottom: 10px;
}
.classroom-header .field {
    flex: 1;
    margin-right: 20px;
    font-size: 14px;
    font-weight: 700;
}
.classroom-header span {
    border-bottom: 1px solid #000;
    padding-right: 50%;
}

/* --- CONTROLS SIDEBAR --- */
.controls-sidebar {
    flex: 0 0 280px;
    padding: 20px;
    border-right: 1px solid #eee;
    background: #fcfcfc;
    color: #333;
}
.controls-sidebar h2 {
    color: var(--theme-primary-color);
    font-size: 20px;
    font-weight: 700;
    margin-top: 0;
    border-bottom: 2px solid var(--theme-primary-color);
    padding-bottom: 5px;
    margin-bottom: 20px;
}
.control-group { margin-bottom: 15px; }
.control-group label {
    display: block;
    font-size: 14px;
    font-weight: 700;
    margin-bottom: 5px;
    color: inherit;
}
select, textarea, input[type="color"], input[type="text"], input[type="number"] {
    width: 100%;
    padding: 8px;
    border-radius: 4px;
    border: 1px solid #ccc;
    box-sizing: border-box;
    font-size: 14px;
}
input[type="color"] { height: 40px; padding: 2px; }
textarea { height: 70px; resize: vertical; }

/* ADJUSTMENT: Custom Grid Size Styling - Increased visibility */
.size-inputs { display: flex; gap: 20px; }
.size-inputs > div { flex: 1; }
.size-inputs input { width: 100%; }
.size-inputs label { font-size: 12px; font-weight: normal; margin-bottom: 2px;}

.btn-generate {
    background-color: var(--theme-secondary-color);
    color: white;
    padding: 12px;
    font-size: 16px;
    font-weight: 700;
    border-radius: 4px;
    cursor: pointer;
    width: 100%;
    margin-top: 15px;
    transition: background-color 0.2s;
    border: none;
}
.btn-utility {
    background-color: #f0f0f0;
    border: 1px solid #ccc;
    color: #333;
    transition: background-color 0.2s;
    border-radius: 4px;
    padding: 10px;
    width: 100%;
}

.checkbox-option { display: flex; align-items: center; gap: 5px; margin-top: 5px; }
.checkbox-option input[type="checkbox"] { width: auto; }
.checkbox-option label { font-weight: normal; margin: 0; }


/* --- MAIN CONTENT & GRID --- */
.main-content { flex-grow: 1; padding: 30px; }
.puzzle-header { text-align: center; margin-bottom: 15px; }
.puzzle-header h1 { color: var(--theme-primary-color); font-weight: 900; margin: 0; }
.puzzle-layout { display: flex; gap: 40px; justify-content: center; }
.puzzle-container { flex: 1; display: flex; justify-content: center; align-items: flex-start; flex-direction: column; }

#puzzleBoard {
    user-select: none; touch-action: none; display: inline-block;
    border: 3px solid var(--theme-primary-color);
    border-radius: 4px;
    margin-top: 10px;
}
#puzzleBoard table { border-collapse: collapse; }
#puzzleBoard td {
    width: 30px; height: 30px; text-align: center; vertical-align: middle;
    font-size: 15px; font-weight: 700; border: 1px solid var(--grid-line-color); cursor: pointer;
    color: #333;
    transition: background-color 0.1s;
}

/* FEATURE: GRID LINE REMOVAL */
#puzzleBoard.no-grid-lines td { border: none !important; }
#puzzleBoard.no-grid-lines table { border-collapse: separate; border-spacing: 0; }

/* --- THEME COLORS & HIGHLIGHTING --- */
#puzzleBoard td.highlight { background: var(--highlight-color); color: #333; }
#puzzleBoard td.found-word { background: var(--highlight-color); color: white; border-color: var(--highlight-color); }

/* --- GRID STYLES (Added bubble) --- */
#puzzleBoard.style-classic td { border-radius: 0; border-color: var(--grid-line-color); }
#puzzleBoard.style-bubble td.highlight,
#puzzleBoard.style-bubble td.found-word { border-radius: 50%; }
#puzzleBoard.style-hollow td { border: 1px solid var(--grid-line-color); }

/* --- WORD LIST & UTILITIES --- */
.word-list-area { flex: 0 0 250px; }
.word-list-area h2 { color: var(--theme-primary-color); font-size: 18px; border-bottom: 1px solid #ccc; padding-bottom: 5px; margin-top: 0; }
#wordBankList { list-style: none; padding: 0; column-count: 2; column-gap: 15px; font-size: 15px; }
#wordBankList li.found { text-decoration: line-through; color: var(--theme-primary-color); font-weight: 700; }

.utility-buttons { margin-top: 20px; }
.utility-buttons button { margin-bottom: 5px; }

/* Print Options Container */
.print-options {
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px dashed #ccc;
    display: flex;
    flex-direction: column;
    gap: 5px;
}
.print-options div {
    display: flex;
    align-items: center;
    gap: 5px;
}
.print-options input[type="checkbox"] { width: auto; }


/* --- ANSWER KEY DISPLAY (Screen) --- */
#answerKeyGrid {
    margin-top: 15px;
    display: none;
    border: 1px solid var(--theme-primary-color);
    padding: 10px;
    border-radius: 4px;
}
#answerKeyGrid table { margin: auto; border-collapse: collapse; }
#answerKeyGrid td { 
    width: 15px; height: 15px; font-size: 10px; text-align: center; border: 1px solid #eee; 
    /* NEW: Answer Key screen highlight for clarity */
    position: relative;
}
/* OLD cell highlight for screen answer key, kept for basic visibility */
#answerKeyGrid td.found-cell { background: var(--theme-primary-color); color: white; } 


/* --- SEASONAL VISUAL THEMES (Colors only, no shapes/images) --- */
body.vtheme-default { --theme-primary-color: #0070c7; --theme-secondary-color: #1e90ff; --app-background: #fff; }
body.vtheme-fall { --theme-primary-color: #a0522d; --theme-secondary-color: #cc6600; --app-background: #fff8e1; }
body.vtheme-winter { --theme-primary-color: #c00; --theme-secondary-color: #008000; --app-background: #f0f8ff; }
body.vtheme-halloween {
    --theme-primary-color: #8B008B; /* Dark Purple */
    --theme-secondary-color: #FFA500; /* Orange Accent */
    --app-background: #f0fff0;
}
body.vtheme-spring { --theme-primary-color: #006400; /* Dark Green */ --theme-secondary-color: #3CB371; --app-background: #f1f8e9; }
body.vtheme-summer { --theme-primary-color: #FFC107; --theme-secondary-color: #F44336; color: #333; --app-background: #fffde7; }
body.vtheme-school { --theme-primary-color: #795548; --theme-secondary-color: #455A64; --app-background: #f5f5f5; }


/* --- PRINT STYLES --- */
@media print {
    #answerKeyGrid:not(.print-include) { display: none !important; }
    body {
        background: none !important;
        padding: 0 !important;
        font-size: 12pt;
        color: #000 !important;
        -webkit-print-color-adjust: exact !important;
        color-adjust: exact !important;
    }
    .controls-sidebar, .utility-buttons, .edurary-credit, .game-stats { display: none !important; }

    .app-container {
        box-shadow: none !important;
        border: 3px solid var(--theme-primary-color) !important;
        /* FIX: Center the printable container */
        display: block !important; 
        margin: 0.2in auto !important; /* Added auto margins for centering and vertical spacing */
        background: var(--app-background) !important;
        width: 100% !important;
        max-width: 7.5in !important; /* Limit width to ensure fit on standard letter/A4 */
        padding: 0.2in !important; 
        box-sizing: border-box !important;
    }
    
    .main-content { 
        padding: 0 !important; 
        width: 100% !important; 
        box-sizing: border-box !important;
        max-width: 100% !important;
    }

    .puzzle-layout { display: block !important; }

    #puzzleBoard { border: 2px solid var(--theme-primary-color) !important; }
    #puzzleBoard td {
        border: var(--print-grid-border) !important;
        background: none !important;
        color: #000 !important;
        border-radius: 0 !important;
    }

    #answerKeyGrid {
        page-break-before: always;
    }
    .edurary-credit-print { display: block !important; color: var(--theme-primary-color) !important; }
}
/* --- NEW: STATS DISPLAY STYLING --- */
.puzzle-stats {
    margin-top: 15px;
    padding: 10px;
    border-top: 1px dashed #ccc;
    font-size: 14px;
    font-weight: 700;
    color: #555;
    text-align: center;
}
.puzzle-stats span {
    display: inline-block;
    margin: 0 10px;
    color: var(--theme-primary-color);
}
</style>
</head>

<body class="vtheme-default">

<div class="app-container" id="appContainer">

    <div class="controls-sidebar">
        <h2>Puzzle Settings</h2>

        <div class="control-group">
            <label for="customTitle">Puzzle Title:</label>
            <input type="text" id="customTitle" placeholder="Word Search Worksheet" oninput="setupGeneration()">
        </div>

        <div class="control-group">
            <label for="visualTheme">Visual Theme (Colors Only):</label>
            <select id="visualTheme" onchange="applyVisualTheme(); setupGeneration()">
                <option value="default" selected>Default Blue</option>
                <option value="spring">Spring üå∑</option>
                <option value="summer">Summer ‚òÄÔ∏è</option>
                <option value="fall">Fall/Thanksgiving üçÇ</option>
                <option value="winter">Winter/Christmas üéÑ</option>
                <option value="halloween">Halloween üéÉ</option>
                <option value="school">Back-to-School ‚úèÔ∏è</option>
            </select>
        </div>

        <div class="control-group">
            <label for="displayTheme">Grid Style:</label>
            <select id="displayTheme" onchange="applyGridTheme()">
                <option value="classic">Classic Squares</option>
                <option value="bubble">Bubble Circles</option>
                <option value="hollow">Hollow Grid</option>
            </select>
        </div>

        <div class="control-group">
            <label for="highlightColor">Highlight Color:</label>
            <input type="color" id="highlightColor" value="#ffcc00" oninput="applyColor()">
        </div>

        <div class="control-group">
            <label for="wordCategory">Choose Category:</label>
            <select id="wordCategory" onchange="handleCategoryChange(); setupGeneration()">
                <option value="custom" selected>Custom Words</option>
                <option value="animals">Animals ü¶Å</option>
                <option value="christmas">Christmas üéÑ</option>
                <option value="thanksgiving">Thanksgiving ü¶É</option>
                <option value="halloween">Halloween üéÉ</option>
                <option value="planets">Planets ü™ê</option>
                <option value="sports">Sports üèà</option>
                <option value="countries">Countries üåé</option>
            </select>
        </div>

        <div class="control-group">
            <label for="wordsInput">Enter Words (One per line/comma-separated):</label>
            <textarea id="wordsInput" placeholder="apple, banana, orange, kiwi, grape" oninput="setupGeneration()">APPLE, BANANA, ORANGE, KIWI, GRAPE</textarea>
        </div>

        <div class="control-group">
            <label>Custom Grid Size (10-30):</label>
            <div class="size-inputs">
                <div>
                    <label for="gridSizeH">Horizontal (Columns)</label>
                    <input type="number" id="gridSizeH" value="15" min="10" max="30" oninput="setupGeneration()">
                </div>
                <div>
                    <label for="gridSizeV">Vertical (Rows)</label>
                    <input type="number" id="gridSizeV" value="15" min="10" max="30" oninput="setupGeneration()">
                </div>
            </div>
        </div>

        <div class="control-group">
            <label for="difficulty">Difficulty/Directions:</label>
            <select id="difficulty" onchange="setupGeneration()">
                <option value="easy">Easy (H/V only, no word reversal)</option>
                <option value="standard" selected>Standard (H/V/Diagonal, no word reversal)</option>
                <option value="hard">Hard (All 8 directions, no word reversal)</option>
                <option value="expert">Expert (All 8 directions, includes word reversal)</option>
            </select>
        </div>

        <div class="control-group print-options" style="border-top: none; padding-top: 0;">
            <div class="checkbox-option">
                <input type="checkbox" id="sortWords" onchange="renderWordBank(currentWords)">
                <label for="sortWords">Sort Word List Alphabetically</label>
            </div>
            <div class="checkbox-option">
                <input type="checkbox" id="removeGridLines" onchange="applyGridLineSetting()">
                <label for="removeGridLines">Remove Internal Grid Lines</label>
            </div>
            <div class="checkbox-option">
                <input type="checkbox" id="repeatWords" onchange="setupGeneration()"> 
                <label for="repeatWords">Allow **duplicate** word placement</label>
            </div>
        </div>

        <button id="generateBtn" class="btn-generate" onclick="setupGeneration()">Generate New Puzzle</button> 

        <div class="edurary-credit">
            Powered by **EDURARY**
        </div>

    </div>

    <div class="main-content">

        <div class="classroom-header">
            <div class="field"><span>Name:</span></div>
            <div class="field"><span>Date:</span></div>
            <div class="field"><span>Class:</span></div>
        </div>

        <div class="puzzle-header">
            <h1 id="puzzleTitle">Word Search Worksheet</h1>
            <p>Find all the words hidden in the grid!</p>
        </div>

        <div class="puzzle-layout">

            <div class="puzzle-container">
                <div id="puzzleBoard" class="style-classic"></div>
                <div class="puzzle-stats">
                    Grid Size: <span id="gridDimensions">15 x 15</span>
                    | Total Placements: <span id="totalPlacements">0</span>
                    | Found: <span id="foundCount">0</span>/<span id="totalUniqueCount">0</span> (Unique)
                </div>
                
            </div>

            <div class="word-list-area">
                <h2>Word Bank</h2>
                <ul id="wordBankList"></ul>

                <div class="utility-buttons">
                    <button id="answerKeyBtn" class="btn-utility" onclick="toggleAnswerKey()">Show Solution (Screen)</button> 
                    <button onclick="savePuzzleAsSVG(true)" class="btn-utility">Export Answer Key (SVG)</button>
                    <button onclick="savePuzzleAsSVG(false)" class="btn-utility">Export Puzzle (SVG)</button>

                    <div class="print-options">
                        <div>
                            <input type="checkbox" id="printAnswerKey">
                            <label for="printAnswerKey" style="font-weight: normal; margin-bottom: 0;">Include Answer Key in Print</label>
                        </div>
                        <button onclick="printPuzzle()" class="btn-utility">Print/Download PDF</button> 
                    </div>
                </div>

                <div id="answerKeyGrid">
                </div>
            </div>
        </div>

        <div id="printCredit" class="edurary-credit-print">
              -- Powered by EDURARY --
        </div>

    </div>
</div>

<script>
// --- WORD CATEGORY DATA ---
const WORD_BANK = {
    custom: { words: "", defaultTitle: "Custom Word Search" },
    animals: { words: "LION,TIGER,BEAR,WOLF,EAGLE,SHARK,DOLPHIN,GIRAFFE,ELEPHANT,MONKEY,RABBIT,FOX,ZEBRA,PANDA,KOALA,SNAKE,FROG,COW,PIG,SHEEP,GOAT,HORSE,DUCK,CAT,DOG", defaultTitle: "Animal Kingdom Puzzle" },
    christmas: { words: "SANTA,REINDEER,SNOWMAN,GIFT,SLEIGH,BELLS,CANDY,MERRY,CAROL,WREATH,LIGHTS,ORNAMENT,CHIMNEY,STOCKING,ELF,GINGERBREAD,HOLLY,FROSTY,NATIVITY,DECEMBER,JOY", defaultTitle: "Christmas Holiday Fun" },
    thanksgiving: { words: "TURKEY,GRAVY,PILGRIM,FEAST,HARVEST,PUMPKIN,BLESSING,FAMILY,AUTUMN,CORN,MAIZE,MAYFLOWER,COLONY,POTATOES,PIE,THANKFUL,CRANBERRY,FRIENDS", defaultTitle: "Thanksgiving Day Puzzle" },
    halloween: { words: "GHOST,PUMPKIN,WITCH,SPIDER,CANDY,SPOOKY,HAUNTED,COSTUME,BAT,SCARED,VAMPIRE,MUMMY,ZOMBIE,BOO,CEMETERY,MOON,BLACKCAT,COBWEB", defaultTitle: "Halloween Spooktacular" },
    planets: { words: "MERCURY,VENUS,EARTH,MARS,JUPITER,SATURN,URANUS,NEPTUNE,ASTEROID,COMET,UNIVERSE,GALAXY,ORBIT,SUN,MOON,STARS", defaultTitle: "Planets of the Solar System" },
    sports: { words: "FOOTBALL,BASKETBALL,SOCCER,TENNIS,GOLF,HOCKEY,VOLLEYBALL,BASEBALL,RUGBY,SWIMMING,RUNNING,CYCLING,BOXING,WRESTLING,SKIING,FENCING,JUMPING", defaultTitle: "Sports Puzzle" },
    countries: { words: "CANADA,MEXICO,BRAZIL,JAPAN,INDIA,GERMANY,FRANCE,CHINA,EGYPT,RUSSIA,CHILE,ITALY,SPAIN,AUSTRALIA,KOREA,VIETNAM,KENYA,PERU,GREECE", defaultTitle: "World Countries Puzzle" }
};

// --- GLOBAL VARIABLES ---
let GRID_SIZE_H = 15; // Horizontal (Columns)
let GRID_SIZE_V = 15; // Vertical (Rows)
let ATTEMPTS_LIMIT = 500;
let grid = [];
let wordPositions = []; // Stores placed words and their coordinates (including duplicates)
let isMouseDown = false;
let dragStartCell = null;
let dragEndCell = null;
let currentWords = []; // Unique words for the Word Bank display
let placedWords = []; // Array of { word: '...', instance: 1 } for tracking and statistics
const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

// --- GENERATION AND SETUP ---

document.addEventListener('DOMContentLoaded', () => {
    // FIX: Ensure setupGeneration runs immediately and handles potential initial errors.
    try {
        setupGeneration();
    } catch (e) {
        console.error("Initial puzzle generation failed:", e);
        // Fallback for visual feedback if JavaScript fails completely
        document.getElementById("puzzleBoard").innerHTML = "<p style='padding: 20px;'>Error loading puzzle. Check console for details.</p>";
    }
});

function getSettings() {
    let sizeH = parseInt(document.getElementById("gridSizeH").value);
    let sizeV = parseInt(document.getElementById("gridSizeV").value);

    GRID_SIZE_H = Math.max(10, Math.min(30, sizeH || 15));
    GRID_SIZE_V = Math.max(10, Math.min(30, sizeV || 15));

    document.getElementById("gridSizeH").value = GRID_SIZE_H;
    document.getElementById("gridSizeV").value = GRID_SIZE_V;

    ATTEMPTS_LIMIT = 500; 
}

function selectWords() {
    const category = document.getElementById("wordCategory").value;
    const repeatWordsAllowed = document.getElementById("repeatWords").checked;
    
    let wordsToPlaceOnGrid = [];
    let rawWordsArray = [];

    if (category === "custom") {
        const rawInput = document.getElementById("wordsInput").value;
        
        rawWordsArray = rawInput
            .split(/[\s,]+/)
            .map(w => w.trim().toUpperCase().replace(/[^A-Z]/g, ''))
            .filter(w => w.length > 1 && w.length <= Math.max(GRID_SIZE_H, GRID_SIZE_V));
    
    } else {
        const wordData = WORD_BANK[category];
        const allWords = wordData.words.split(',').map(w => w.trim().toUpperCase());
        const maxPossibleWords = Math.floor((GRID_SIZE_H + GRID_SIZE_V) / 4);
        const effectiveWordCount = Math.max(6, Math.min(25, maxPossibleWords));
        
        // Shuffle the array and take the top N words (unique is handled below)
        for (let i = allWords.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [allWords[i], allWords[j]] = [allWords[j], allWords[i]];
        }
        rawWordsArray = allWords.slice(0, effectiveWordCount);
        // IMPORTANT: Update the wordsInput box if a category is selected
        document.getElementById("wordsInput").value = rawWordsArray.join('\n'); 
    }
    
    // 1. Determine the list for placement
    if (repeatWordsAllowed) {
        wordsToPlaceOnGrid = rawWordsArray;
    } else {
        wordsToPlaceOnGrid = Array.from(new Set(rawWordsArray));
    }
    
    // 2. Determine the list for the Word Bank (MUST be unique words)
    currentWords = Array.from(new Set(rawWordsArray.filter(w => w.length > 0))).slice(0, 50);

    return wordsToPlaceOnGrid;
}


function setupGeneration() {
    getSettings();

    const wordsToPlace = selectWords();

    if (!wordsToPlace.length) {
        document.getElementById("puzzleBoard").innerHTML = "<table style='margin: auto; margin-top: 10px;'><tr><td>N</td><td>O</td></tr><tr><td>W</td><td>O</td></tr></table>";
        document.getElementById("wordBankList").innerHTML = "<li>No valid words to generate.</li>";
        updateStats(0, currentWords.length);
        return;
    }

    applyVisualTheme();
    applyColor();
    applyGridTheme();
    applyGridLineSetting();

    const category = document.getElementById("wordCategory").value;
    const customTitleInput = document.getElementById("customTitle").value.trim();
    const categoryTitle = WORD_BANK[category] ? WORD_BANK[category].defaultTitle : "Word Search Worksheet";
    document.getElementById("puzzleTitle").textContent = customTitleInput || categoryTitle;

    grid = Array(GRID_SIZE_V).fill().map(() => Array(GRID_SIZE_H).fill(""));
    wordPositions = [];
    placedWords = [];
    
    // Reset game state
    foundWordInstances = {};
    
    generateGrid(wordsToPlace); 
    renderGrid();
    renderWordBank(currentWords); 
    renderAnswerKey();
    enableGameMode();
    
    updateStats(placedWords.length, currentWords.length);
}

function updateStats(totalPlacements, totalUniqueCount) {
    document.getElementById("gridDimensions").textContent = `${GRID_SIZE_V} x ${GRID_SIZE_H}`;
    document.getElementById("totalPlacements").textContent = totalPlacements;
    document.getElementById("totalUniqueCount").textContent = totalUniqueCount;
    // The found count represents the number of total *placements* found
    document.getElementById("foundCount").textContent = 0; 
}

function applyVisualTheme() {
    const theme = document.getElementById("visualTheme").value;
    document.body.className = `vtheme-${theme}`;
}

function applyColor() {
    const color = document.getElementById("highlightColor").value;
    document.body.style.setProperty('--highlight-color', color);
}

function applyGridTheme() {
    const theme = document.getElementById("displayTheme").value;
    const board = document.getElementById("puzzleBoard");
    board.className = `style-${theme}`;
    applyGridLineSetting();
}

function applyGridLineSetting() {
    const board = document.getElementById("puzzleBoard");
    const removeLines = document.getElementById("removeGridLines").checked;
    if (removeLines) {
        board.classList.add("no-grid-lines");
        document.body.style.setProperty('--print-grid-border', 'none');
    } else {
        board.classList.remove("no-grid-lines");
        document.body.style.setProperty('--print-grid-border', '1px solid #000');
    }
}

function generateGrid(words) {
    const difficultyLevel = document.getElementById("difficulty").value;
    
    const directionsMap = {
        easy: [[0, 1], [1, 0]], 
        standard: [[0, 1], [1, 0], [1, 1], [1, -1]], 
        hard: [[0, 1], [1, 0], [1, 1], [1, -1], [-1, 1], [-1, 0], [0, -1], [-1, -1]], 
        expert: [[0, 1], [1, 0], [1, 1], [1, -1], [-1, 1], [-1, 0], [0, -1], [-1, -1]]
    };
    
    let directions = directionsMap[difficultyLevel] || directionsMap.standard;

    // Sort words by length for better placement chances
    let wordsToPlace = [...words].sort((a, b) => b.length - a.length);
    
    wordPositions = [];
    placedWords = []; 
    let wordInstanceCounters = {}; // Tracks how many times a word has been placed (for the placedWords array)

    wordsToPlace.forEach(word => {
        let actualWord = word;
        if (difficultyLevel === 'expert' && Math.random() < 0.5) { 
            actualWord = word.split('').reverse().join('');
        }
        
        for (let attempts = 0; attempts < ATTEMPTS_LIMIT; attempts++) {
            let r = Math.floor(Math.random() * GRID_SIZE_V);
            let c = Math.floor(Math.random() * GRID_SIZE_H);
            let d = directions[Math.floor(Math.random() * directions.length)];

            if (canPlaceWord(actualWord, r, c, d)) {
                let coords = [];
                for (let i = 0; i < actualWord.length; i++) {
                    let rr = r + i * d[0];
                    let cc = c + i * d[1];
                    grid[rr][cc] = actualWord[i];
                    coords.push([rr, cc]);
                }
                
                wordInstanceCounters[word] = (wordInstanceCounters[word] || 0) + 1;

                // Store placement details (original word and coordinates)
                wordPositions.push({ 
                    word: word, 
                    coords, 
                    instance: wordInstanceCounters[word],
                    isFound: false 
                }); 
                
                // Track for statistics and game logic (this tracks the unique list of placements, not the unique words)
                placedWords.push({ 
                    word: word, 
                    instance: wordInstanceCounters[word],
                    isFound: false
                });

                break;
            }
        }
    });

    // Fill remaining cells with random letters
    for (let r = 0; r < GRID_SIZE_V; r++)
        for (let c = 0; c < GRID_SIZE_H; c++)
            if (!grid[r][c]) grid[r][c] = letters[Math.floor(Math.random() * letters.length)];
}

function canPlaceWord(word, r, c, d) {
    for (let i = 0; i < word.length; i++) {
        let rr = r + i * d[0];
        let cc = c + i * d[1];
        if (rr < 0 || cc < 0 || rr >= GRID_SIZE_V || cc >= GRID_SIZE_H) return false;
        if (grid[rr][cc] !== "" && grid[rr][cc] !== word[i]) return false;
    }
    return true;
}

function renderGrid() {
    let html = "<table>";
    const maxGridSize = Math.max(GRID_SIZE_H, GRID_SIZE_V);
    const cellSize = Math.max(20, 450 / maxGridSize);

    for (let r = 0; r < GRID_SIZE_V; r++) {
        html += "<tr>";
        for (let c = 0; c < GRID_SIZE_H; c++)
            html += `<td data-r="${r}" data-c="${c}" style="width:${cellSize}px; height:${cellSize}px; font-size:${cellSize*0.6}px;">${grid[r][c]}</td>`;
        html += "</tr>";
    }
    html += "</table>";
    document.getElementById("puzzleBoard").innerHTML = html;
}

function renderWordBank(words) {
    const ul = document.getElementById("wordBankList");
    ul.innerHTML = "";

    let wordsToRender = [...words];
    if (document.getElementById("sortWords").checked) {
        wordsToRender.sort((a, b) => a.localeCompare(b));
    }

    // Use currentWords (the unique list) for the word bank list
    wordsToRender.forEach(w => ul.innerHTML += `<li id="word-bank-${w}">${w}</li>`);
}

function renderAnswerKey() {
    let keyHtml = "<table>";
    let keyGrid = Array(GRID_SIZE_V).fill().map(() => Array(GRID_SIZE_H).fill(false));

    wordPositions.forEach(entry => {
        entry.coords.forEach(([r, c]) => {
            keyGrid[r][c] = true;
        });
    });

    for (let r = 0; r < GRID_SIZE_V; r++) {
        keyHtml += "<tr>";
        for (let c = 0; c < GRID_SIZE_H; c++) {
            const class_ = keyGrid[r][c] ? 'found-cell' : '';
            keyHtml += `<td class="${class_}">${grid[r][c]}</td>`;
        }
        keyHtml += "</tr>";
    }
    keyHtml += "</table>";
    document.getElementById("answerKeyGrid").innerHTML = `<p style="text-align: center; font-weight: bold; margin-bottom: 5px;">ANSWER KEY (Cell Highlight)</p>` + keyHtml;
}

function toggleAnswerKey() {
    const keyDiv = document.getElementById("answerKeyGrid");
    const btn = document.getElementById("answerKeyBtn");
    const isVisible = keyDiv.style.display === 'block';

    keyDiv.style.display = isVisible ? 'none' : 'block';
    btn.textContent = isVisible ? 'Show Solution (Screen)' : 'Hide Solution (Screen)';
}

function handleCategoryChange() {
    const category = document.getElementById("wordCategory").value;
    const wordsInput = document.getElementById("wordsInput");

    if (category === "custom") {
        wordsInput.disabled = false;
        wordsInput.placeholder = "Enter your own words...";
    } else {
        wordsInput.disabled = true;
        if (WORD_BANK[category]) {
             selectWords(); 
        }
    }
}

function printPuzzle() {
    const answerKeyDiv = document.getElementById("answerKeyGrid");
    const printKeyCheckbox = document.getElementById("printAnswerKey");
    const screenIsVisible = answerKeyDiv.style.display === 'block';

    if (printKeyCheckbox.checked) {
        answerKeyDiv.style.setProperty('display', 'block', 'important');
    }

    if (printKeyCheckbox.checked) {
        answerKeyDiv.classList.add('print-include');
    } else {
        answerKeyDiv.classList.remove('print-include');
    }

    window.print();

    answerKeyDiv.classList.remove('print-include');
    answerKeyDiv.style.removeProperty('display');

    if (!screenIsVisible) {
        answerKeyDiv.style.display = 'none';
    } else {
        answerKeyDiv.style.display = 'block';
    }
}

function savePuzzleAsSVG(includeAnswerKey) {
    const sizeH = GRID_SIZE_H;
    const sizeV = GRID_SIZE_V;
    const cellSize = 30;
    const padding = 10;
    const title = document.getElementById('puzzleTitle').textContent || "Word Search";

    const puzzleWidth = sizeH * cellSize + 2 * padding;
    const titleHeight = 30;
    const listXOffset = puzzleWidth + 20;

    const maxWordLength = currentWords.reduce((max, w) => Math.max(max, w.length), 0);
    const wordListWidth = Math.max(200, maxWordLength * 12 + 40); 
    const svgWidth = puzzleWidth + wordListWidth; 
    const svgHeight = sizeV * cellSize + titleHeight + 2 * padding;

    let svgContent = `<svg width="${svgWidth}" height="${svgHeight}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${svgWidth} ${svgHeight}">`;

    // --- PUZZLE GRID DRAWING ---
    const gridYOffset = titleHeight;

    svgContent += `<text x="${puzzleWidth / 2}" y="20" font-family="Lato, sans-serif" font-size="20" font-weight="900" text-anchor="middle" fill="#333">${title}</text>`;

    const removeLines = document.getElementById("removeGridLines").checked;
    const gridLineColor = removeLines ? "none" : "#ccc";
    const primaryColor = getComputedStyle(document.body).getPropertyValue('--theme-primary-color').trim();

    svgContent += `<rect x="${padding}" y="${gridYOffset}" width="${sizeH * cellSize}" height="${sizeV * cellSize}" fill="none" stroke="${primaryColor}" stroke-width="3"/>`;

    // Draw Grid Lines and Letters
    for (let r = 0; r < sizeV; r++) {
        for (let c = 0; c < sizeH; c++) {
            const x = c * cellSize + padding;
            const y = r * cellSize + gridYOffset;
            const letter = grid[r][c];

            if (!removeLines) {
                svgContent += `<rect x="${x}" y="${y}" width="${cellSize}" height="${cellSize}" fill="none" stroke="${gridLineColor}" stroke-width="1"/>`;
            }

            svgContent += `<text x="${x + cellSize / 2}" y="${y + cellSize / 2 + 5}" font-family="Lato, sans-serif" font-size="18" text-anchor="middle" dominant-baseline="central" fill="#333">${letter}</text>`;
        }
    }
    
    // --- DRAW CIRCLE/LINE FOR ANSWER KEY ---
    if (includeAnswerKey) {
        const strokeColor = getComputedStyle(document.body).getPropertyValue('--theme-primary-color').trim();
        wordPositions.forEach(entry => {
            const coords = entry.coords;
            if (coords.length > 0) {
                const startR = coords[0][0];
                const startC = coords[0][1];
                const endR = coords[coords.length - 1][0];
                const endC = coords[coords.length - 1][1];
                
                // Calculate center point of start and end cells
                const x1 = startC * cellSize + padding + (cellSize / 2);
                const y1 = startR * cellSize + gridYOffset + (cellSize / 2);
                const x2 = endC * cellSize + padding + (cellSize / 2);
                const y2 = endR * cellSize + gridYOffset + (cellSize / 2);

                // Draw a thick line over the entire word
                svgContent += `<line 
                    x1="${x1}" y1="${y1}" 
                    x2="${x2}" y2="${y2}" 
                    stroke="${strokeColor}" 
                    stroke-width="15" 
                    stroke-linecap="round" 
                    opacity="0.5"
                />`;
            }
        });
    }


    // --- WORD LIST DRAWING ---
    const listYOffset = titleHeight + 10;
    const lineSpacing = 25; 
    const listWords = [...currentWords];
    if (document.getElementById("sortWords").checked) {
        listWords.sort((a, b) => a.localeCompare(b));
    }

    svgContent += `<text x="${listXOffset}" y="${listYOffset - 10}" font-family="Lato, sans-serif" font-size="16" font-weight="700" fill="${primaryColor}">Word Bank</text>`;
    listWords.forEach((word, index) => {
        svgContent += `<text x="${listXOffset}" y="${listYOffset + index * lineSpacing}" font-family="Lato, sans-serif" font-size="14" fill="#333">${word}</text>`;
    });

    svgContent += `</svg>`;

    const filename = `${title.replace(/\s/g, '_')}_${includeAnswerKey ? 'Solution' : 'Puzzle'}.svg`;
    const blob = new Blob([svgContent], { type: 'image/svg+xml;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
}


// --- DRAG LOGIC (Kept for functionality) ---

// Map to store which instances of a duplicated word have been found
let foundWordInstances = {}; 

function enableGameMode() {
    const board = document.getElementById("puzzleBoard");
    board.onmousedown = e => {
        if (e.target.tagName !== "TD") return;
        isMouseDown = true;
        dragStartCell = e.target;
        dragEndCell = e.target;
        highlightDrag();
    };
    board.onmouseover = e => {
        if (!isMouseDown || e.target.tagName !== "TD") return;
        dragEndCell = e.target;
        highlightDrag();
    };
    board.onmouseup = e => {
        if (!isMouseDown || e.target.tagName !== "TD") return;
        isMouseDown = false;
        dragEndCell = e.target;
        checkWord();
        clearHighlight();
    };
    board.onmouseleave = () => {
        if (isMouseDown) {
            isMouseDown = false;
            clearHighlight();
        }
    };
    
    // Reset found state for the new puzzle
    wordPositions.forEach(p => p.isFound = false);
    foundWordInstances = {};

    document.getElementById("answerKeyGrid").style.display = 'none';
    document.getElementById("answerKeyBtn").textContent = 'Show Solution (Screen)';
}

function highlightDrag() {
    const board = document.getElementById("puzzleBoard");
    const cells = board.querySelectorAll('td');
    cells.forEach(cell => cell.classList.remove('highlight'));

    if (!dragStartCell || !dragEndCell) return;

    const startR = parseInt(dragStartCell.dataset.r);
    const startC = parseInt(dragStartCell.dataset.c);
    const endR = parseInt(dragEndCell.dataset.r);
    const endC = parseInt(dragEndCell.dataset.c);

    const dR = endR - startR;
    const dC = endC - startC;
    const length = Math.max(Math.abs(dR), Math.abs(dC));

    // Determine direction (must be horizontal, vertical, or diagonal)
    const stepR = (dR === 0) ? 0 : dR / Math.abs(dR);
    const stepC = (dC === 0) ? 0 : dC / Math.abs(dC);

    if (Math.abs(dR) !== length && Math.abs(dC) !== length && dR !== 0 && dC !== 0) {
        // Not a straight line
        dragStartCell.classList.add('highlight');
        dragEndCell.classList.add('highlight');
        return;
    }

    for (let i = 0; i <= length; i++) {
        const r = startR + i * stepR;
        const c = startC + i * stepC;
        const cell = board.querySelector(`[data-r="${r}"][data-c="${c}"]`);
        if (cell) cell.classList.add('highlight');
    }
}

function clearHighlight() {
    document.getElementById("puzzleBoard").querySelectorAll('td').forEach(cell => cell.classList.remove('highlight'));
    dragStartCell = null;
    dragEndCell = null;
}

function getPath(startR, startC, endR, endC) {
    const dR = endR - startR;
    const dC = endC - startC;
    const length = Math.max(Math.abs(dR), Math.abs(dC));

    const path = [];

    if (length === 0) {
        path.push({r: startR, c: startC});
        return path;
    }
    
    const isStraight = (Math.abs(dR) === 0 || Math.abs(dC) === 0 || Math.abs(dR) === Math.abs(dC));
    
    if (isStraight) {
        const stepR = (dR === 0) ? 0 : dR / Math.abs(dR);
        const stepC = (dC === 0) ? 0 : dC / Math.abs(dC);

        for (let i = 0; i <= length; i++) {
            path.push({r: startR + i * stepR, c: startC + i * stepC});
        }
    }
    
    return path;
}

function coordsMatch(coord1, coord2) {
    return coord1[0] === coord2[0] && coord1[1] === coord2[1];
}

function checkWord() {
    if (!dragStartCell || !dragEndCell) return;

    const startR = parseInt(dragStartCell.dataset.r);
    const startC = parseInt(dragStartCell.dataset.c);
    const endR = parseInt(dragEndCell.dataset.r);
    const endC = parseInt(dragEndCell.dataset.r); // Correction from previous: should be endC = endCell.dataset.c

    // Re-read endC safely
    const tempEndC = parseInt(dragEndCell.dataset.c);
    if (isNaN(tempEndC)) return; // Stop if coordinates are invalid
    const actualEndC = tempEndC;


    const path = getPath(startR, startC, endR, actualEndC);
    if (path.length < 2) return;

    const selectedWord = path.map(p => grid[p.r][p.c]).join('');
    const reversedWord = selectedWord.split('').reverse().join('');
    
    const selectedCoords = path.map(p => [p.r, p.c]);

    let matchingPlacementIndex = -1;
    
    // Find the *first unfound* placement that matches the selected word and coordinates
    for (let i = 0; i < wordPositions.length; i++) {
        const placement = wordPositions[i];
        
        if (placement.isFound) continue;

        // Check the word match (forward or backward match against the original word)
        if (placement.word !== selectedWord && placement.word !== reversedWord) continue;

        // Check if the coordinates match the path (forward or reversed)
        const forwardMatch = placement.coords.length === selectedCoords.length && 
                             placement.coords.every((coord, index) => coordsMatch(coord, selectedCoords[index]));
        
        const reverseCoords = [...selectedCoords].reverse();
        const backwardMatch = placement.coords.length === reverseCoords.length &&
                              placement.coords.every((coord, index) => coordsMatch(coord, reverseCoords[index]));

        if (forwardMatch || backwardMatch) {
            matchingPlacementIndex = i;
            break;
        }
    }

    if (matchingPlacementIndex !== -1) {
        const placement = wordPositions[matchingPlacementIndex];
        const uniqueWord = placement.word;

        // Mark the placement as found
        placement.isFound = true;
        
        // Highlight the cells
        path.forEach(p => {
            const cell = document.querySelector(`#puzzleBoard [data-r="${p.r}"][data-c="${p.c}"]`);
            if (cell) cell.classList.add('found-word');
        });

        // Update word list status based on unique word count
        const totalUniqueInstances = wordPositions.filter(p => p.word === uniqueWord).length;
        const foundUniqueInstances = wordPositions.filter(p => p.word === uniqueWord && p.isFound).length;
        
        if (foundUniqueInstances === totalUniqueInstances) {
            const listItem = document.getElementById(`word-bank-${uniqueWord}`);
            if (listItem) listItem.classList.add('found');
        }

        // Update stats. Total placements is the new target count.
        const totalFoundPlacements = wordPositions.filter(p => p.isFound).length;
        document.getElementById('foundCount').textContent = totalFoundPlacements;
        
        // Check win condition
        if (totalFoundPlacements === wordPositions.length) {
            alert("Congratulations! You found all the words!");
        }
    }
}
</script>
</body>
</html>
